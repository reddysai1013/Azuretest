name: Azure Install/Update & Configure OpenTelemetry Agent

on:
  schedule:
    - cron: "0 0 1 * *"  # Runs at 00:00 UTC on the 1st of every month
  workflow_dispatch:  # Allows manual execution

jobs:
  otel-contrib-agent:
    permissions:
      id-token: write  # Required for OIDC token fetching
      contents: read   # Required for actions/checkout
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.CHARAN_TOKEN }}
      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Get Azure Linux VMs by OTEL Tag
        id: get-linux-vms
        run: |
          echo "Querying all VMs with OTEL=True..."
          az vm list \
            --show-details \
            --query "[?tags.OTEL == 'True'].{name:name, resourceGroup:resourceGroup, powerState:powerState}" \
            --output tsv > linux_vms.tsv
          
          if [[ ! -s linux_vms.tsv ]]; then
            echo "No Linux VMs found with OTEL=True tag"
            exit 0
          fi
          
          echo "Contents of linux_vms.tsv:"
          cat linux_vms.tsv
          
          VM_NAMES=$(awk '{print $1}' linux_vms.tsv | tr '\n' ' ' | sed 's/ *$//')
          echo "Found Linux VM Names: $VM_NAMES"
          echo "VM_NAMES=$VM_NAMES" >> $GITHUB_ENV

      - name: Upload TSV as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: linux-vms-tsv
          path: linux_vms.tsv

      - name: Get VM Architecture for Running VMs
        run: |
          ACTIVE_VM_NAMES=()
          SKIPPED_VM_NAMES=()
          mkdir -p vm_architecture_logs
          mkdir -p vm_skipped_logs
          
          while IFS=$'\t' read -r VM_NAME RESOURCE_GROUP VM_STATE; do
            echo "Processing $VM_NAME in resource group $RESOURCE_GROUP"
            
            # Check if VM is running
            if [[ "$VM_STATE" == "PowerState/running" || "$VM_STATE" == "VM running" ]]; then
              echo "VM $VM_NAME is running. Getting architecture..."
              
              # Get VM size to determine architecture
              VM_SIZE=$(az vm show \
                --name "$VM_NAME" \
                --resource-group "$RESOURCE_GROUP" \
                --query 'hardwareProfile.vmSize' \
                --output tsv 2>/dev/null)
              
              if [[ -n "$VM_SIZE" ]]; then
                echo "VM Size: $VM_SIZE" >> "vm_architecture_logs/${VM_NAME}.log"
                
                # Map VM size to architecture
                case "$VM_SIZE" in
                  *_A*|*_D*|*_E*|*_F*|*_G*|*_H*|*_L*|*_M*|*_N*|*_S*|Standard_B*|Standard_DC*|Standard_NC*|Standard_ND*|Standard_NP*|Standard_NV*)
                    ARCH_NAME="amd64"
                    ;;
                  *ps_*|*pbs_*|*pd_*|*pm_*|*Dpls_*|*Epls_*|*Epsv*)
                    ARCH_NAME="arm64"
                    ;;
                  *)
                    echo "Unknown VM size pattern: $VM_SIZE, defaulting to amd64" >> "vm_architecture_logs/${VM_NAME}.log"
                    ARCH_NAME="amd64"
                    ;;
                esac
                
                echo "VM $VM_NAME architecture: $ARCH_NAME"
                echo "VM: $VM_NAME, RG: $RESOURCE_GROUP, Architecture: $ARCH_NAME" >> "vm_architecture_logs/${VM_NAME}.log"
                ACTIVE_VM_NAMES+=("$VM_NAME")
                
                # Create safe environment variable names
                SAFE_VM_NAME=$(echo "$VM_NAME" | tr -C '[:alnum:]' '_' | sed 's/^[0-9]/_&/')
                
                if [[ -n "$SAFE_VM_NAME" ]]; then
                  echo "ARCH_$SAFE_VM_NAME=$ARCH_NAME" >> $GITHUB_ENV
                  echo "RG_$SAFE_VM_NAME=$RESOURCE_GROUP" >> $GITHUB_ENV
                fi
              else
                echo "Could not determine VM size for $VM_NAME"
                echo "VM: $VM_NAME, RG: $RESOURCE_GROUP, Reason: Could not determine VM size" >> "vm_skipped_logs/${VM_NAME}_skipped.log"
                SKIPPED_VM_NAMES+=("$VM_NAME (size detection failed)")
              fi
            else
              echo "VM $VM_NAME is not running (state: $VM_STATE). Skipping architecture detection."
              echo "VM: $VM_NAME, RG: $RESOURCE_GROUP, State: $VM_STATE, Reason: VM not running" >> "vm_skipped_logs/${VM_NAME}_skipped.log"
              SKIPPED_VM_NAMES+=("$VM_NAME ($VM_STATE)")
            fi
            
            sleep 1  # Avoid Azure API rate limits
          done < linux_vms.tsv

          echo "Active VMs with architecture detected: ${ACTIVE_VM_NAMES[*]}"
          echo "Skipped VMs: ${SKIPPED_VM_NAMES[*]}"
          echo "ACTIVE_VM_NAMES=${ACTIVE_VM_NAMES[*]}" >> $GITHUB_ENV
          echo "SKIPPED_VM_NAMES=${SKIPPED_VM_NAMES[*]}" >> $GITHUB_ENV

      - name: Upload VM Processing Logs
        uses: actions/upload-artifact@v4
        with:
          name: vm-processing-logs
          path: |
            vm_architecture_logs/
            vm_skipped_logs/

      - name: Summary Report
        run: |
          echo "=== VM Processing Summary ==="
          echo "Total VMs found with OTEL=True tag: $(wc -l < linux_vms.tsv)"
          
          # Handle active VMs
          if [[ -n "$ACTIVE_VM_NAMES" && "$ACTIVE_VM_NAMES" != " " ]]; then
            ACTIVE_COUNT=$(echo "$ACTIVE_VM_NAMES" | wc -w)
          else
            ACTIVE_COUNT=0
          fi
          
          # Handle skipped VMs
          if [[ -n "$SKIPPED_VM_NAMES" && "$SKIPPED_VM_NAMES" != " " ]]; then
            SKIPPED_COUNT=$(echo "$SKIPPED_VM_NAMES" | wc -w)
          else
            SKIPPED_COUNT=0
          fi
          
          echo "Active VMs processed: $ACTIVE_COUNT"
          echo "Skipped VMs: $SKIPPED_COUNT"
          echo ""
          echo "=== Active VMs ==="
          if [[ $ACTIVE_COUNT -gt 0 ]]; then
            echo "$ACTIVE_VM_NAMES" | tr ' ' '\n' | while read -r vm; do
              if [[ -n "$vm" ]]; then
                echo "  - $vm"
              fi
            done
          else
            echo "  No active VMs found"
          fi
          echo ""
          echo "=== Skipped VMs ==="
          if [[ $SKIPPED_COUNT -gt 0 ]]; then
            echo "$SKIPPED_VM_NAMES" | tr ' ' '\n' | while read -r vm; do
              if [[ -n "$vm" ]]; then
                echo "  - $vm"
              fi
            done
          else
            echo "  No VMs were skipped"
          fi

      - name: Copy Missing Config Files and Commit - Linux
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
         
          CHANGES_MADE=false
         
          for INSTANCE_ID in $ACTIVE_VM_NAMES; do
            CONFIG_FILE="agents/otel/config/Linux/$INSTANCE_ID.yaml"
        
            # If the config file is missing, copy the default config and commit it
            if [[ ! -f "$CONFIG_FILE" ]]; then
              echo "Config file for $INSTANCE_ID not found. Copying default..."
              cp agents/otel/config/aws-otel-agent-coralogix-sherpa.yaml "$CONFIG_FILE"
              git add "$CONFIG_FILE"
              CHANGES_MADE=true
            fi
          done

          # Commit and push if new config files were copied
          if [[ "$CHANGES_MADE" == true ]]; then
            git commit -m "Copy default config files for instances [ci skip]"
            git push origin main
          else
            echo "No new config files copied, no push needed."
          fi

        env:
          GITHUB_TOKEN: ${{ secrets.CHARAN_TOKEN }}


      - name: Inject Private API Key into Config Files
        run: |
          for INSTANCE_ID in $ACTIVE_VM_NAMES; do
            CONFIG_FILE="agents/otel/config/Linux/$INSTANCE_ID.yaml"
            # Replace Private API key in the config file (if needed)
            if [[ -f "$CONFIG_FILE" ]]; then
              sed -i "s/private_key: \"REPLACE_ME\"/private_key: \"${SHERPA_PRIVATE_KEY}\"/" "$CONFIG_FILE"
              git add "$CONFIG_FILE"
            fi
          done

        env:
          SHERPA_PRIVATE_KEY: ${{ secrets.SHERPA_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.CHARAN_TOKEN }}