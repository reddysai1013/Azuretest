name: Azure Install/Update & Configure OpenTelemetry Agent

on:
  push:
    branches:
      - main

jobs:
  otel-contrib-agent:
    permissions:
      id-token: write  # Required for OIDC token fetching
      contents: read   # Required for actions/checkout
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.CHARAN_TOKEN }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Validate Secrets
        run: |
          if [[ -z "${{ secrets.AZURE_CLIENT_ID }}" || -z "${{ secrets.AZURE_TENANT_ID }}" || -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" || -z "${{ secrets.CHARAN_TOKEN }}" ]]; then
            echo "Error: One or more required secrets (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID, CHARAN_TOKEN) are missing."
            exit 1
          fi

      - name: Azure CLI Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Azure Linux VMs by OTEL Tag
        id: get-linux-vms
        run: |
          echo "Querying all VMs with OTEL=True..."
          az vm list \
            --show-details \
            --query "[?tags.OTEL == 'True'].{name:name, resourceGroup:resourceGroup, powerState:powerState}" \
            --output tsv > linux_vms.tsv || { echo "Failed to list VMs"; exit 1; }
          
          if [[ ! -s linux_vms.tsv ]]; then
            echo "No Linux VMs found with OTEL=True tag"
            echo "VM_NAMES=" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Contents of linux_vms.tsv:"
          cat linux_vms.tsv
          
          VM_NAMES=$(awk '{print $1}' linux_vms.tsv | tr '\n' ' ' | sed 's/ *$//')
          echo "Found Linux VM Names: $VM_NAMES"
          echo "VM_NAMES=$VM_NAMES" >> $GITHUB_ENV

      - name: Upload TSV as Artifact
        if: steps.get-linux-vms.outputs.VM_NAMES != ''
        uses: actions/upload-artifact@v4
        with:
          name: linux-vms-tsv
          path: linux_vms.tsv

      - name: Ensure Run Command Extension
        run: |
          echo "Installing run command extension on VMs..."
          mkdir -p extension_logs
          
          while IFS=$'\t' read -r VM_NAME RESOURCE_GROUP VM_STATE; do
            if [[ "$VM_STATE" == "PowerState/running" || "$VM_STATE" == "VM running" ]]; then
              echo "Installing run command extension on $VM_NAME..."
              az vm extension set \
                --name RunCommandLinux \
                --publisher Microsoft.CPlat.Core \
                --vm-name "$VM_NAME" \
                --resource-group "$RESOURCE_GROUP" \
                --no-wait \
                --output json > "extension_logs/${VM_NAME}_extension.json" 2>&1 || echo "Extension might already be installed on $VM_NAME"
            fi
          done < linux_vms.tsv
          
          echo "Waiting for extensions to be ready..."
          sleep 45

      - name: Check VMs/Architectures/Status
        run: |
          ACTIVE_VM_NAMES=()
          SKIPPED_VMS=()
          echo "Skipped VMs:" > skipped_vms.log
          mkdir -p debug_logs

          while IFS=$'\t' read -r VM_NAME RESOURCE_GROUP VM_STATE; do
            echo "Checking $VM_NAME in resource group $RESOURCE_GROUP"
            
            # Handle missing or unknown VM_STATE
            if [[ -z "$VM_STATE" || "$VM_STATE" == "Unknown" ]]; then
              echo "VM_STATE missing or unknown for $VM_NAME, querying Azure..."
              VM_STATE=$(az vm get-instance-view \
                --name "$VM_NAME" \
                --resource-group "$RESOURCE_GROUP" \
                --query 'instanceView.statuses[?code==`PowerState/running`].code' \
                --output tsv 2>/dev/null || echo "")
              
              if [[ -z "$VM_STATE" ]]; then
                echo "Failed to retrieve state for $VM_NAME. Skipping..." | tee -a skipped_vms.log
                SKIPPED_VMS+=("$VM_NAME")
                continue
              fi
            fi

            # Check if VM is running
            if [[ "$VM_STATE" != "PowerState/running" && "$VM_STATE" != "VM running" ]]; then
              echo "VM $VM_NAME is in state: $VM_STATE. Skipping..." | tee -a skipped_vms.log
              SKIPPED_VMS+=("$VM_NAME")
              continue
            fi

            echo "VM $VM_NAME is running. Getting architecture..."
            
            # Get architecture with improved error handling
            RESULT=$(az vm run-command invoke \
              --name "$VM_NAME" \
              --resource-group "$RESOURCE_GROUP" \
              --command-id RunShellScript \
              --scripts "uname -m" \
              --output json 2>&1)
            
            if [[ $? -ne 0 ]]; then
              echo "Failed to run command on $VM_NAME: $RESULT" | tee -a "debug_logs/${VM_NAME}.log"
              echo "Command execution failed for $VM_NAME. Skipping..." | tee -a skipped_vms.log
              SKIPPED_VMS+=("$VM_NAME")
              continue
            fi
            
            # Log the full result for debugging
            echo "Full command result for $VM_NAME:" >> "debug_logs/${VM_NAME}.log"
            echo "$RESULT" >> "debug_logs/${VM_NAME}.log"
            
            # Extract architecture from JSON output
            ARCH=$(echo "$RESULT" | jq -r '.value[0].message' 2>/dev/null | grep -oP '(?<=stdout\]\n)[^\n\r]*(?=\n|\r|\[stderr\])' | tr -d '\r\n' | xargs)
            
            if [[ -z "$ARCH" ]]; then
              echo "Could not determine architecture for $VM_NAME" | tee -a "debug_logs/${VM_NAME}.log"
              echo "Architecture parsing failed for $VM_NAME. Skipping..." | tee -a skipped_vms.log
              SKIPPED_VMS+=("$VM_NAME")
              continue
            fi
            
            echo "Detected architecture for $VM_NAME: '$ARCH'" >> "debug_logs/${VM_NAME}.log"
            
            # Map architecture to standard names
            case "$ARCH" in
              x86_64) ARCH_NAME="amd64" ;;
              aarch64|arm64) ARCH_NAME="arm64" ;;
              *)
                echo "Unsupported architecture: '$ARCH' on $VM_NAME. Skipping..." | tee -a skipped_vms.log
                SKIPPED_VMS+=("$VM_NAME")
                continue
                ;;
            esac

            echo "VM $VM_NAME is using architecture: $ARCH_NAME"
            ACTIVE_VM_NAMES+=("$VM_NAME")
            
            # Create safe environment variable names
            SAFE_VM_NAME=$(echo "$VM_NAME" | tr -C '[:alnum:]' '_' | sed 's/^[0-9]/_&/')
            
            if [[ -n "$SAFE_VM_NAME" ]]; then
              echo "ARCH_$SAFE_VM_NAME=$ARCH_NAME" >> $GITHUB_ENV
              echo "RG_$SAFE_VM_NAME=$RESOURCE_GROUP" >> $GITHUB_ENV
            else
              echo "Could not create safe environment variable name for $VM_NAME" | tee -a skipped_vms.log
            fi
            
            sleep 2  # Avoid Azure API rate limits
          done < linux_vms.tsv

          echo "Active VMs: ${ACTIVE_VM_NAMES[*]}"
          echo "Skipped VMs: ${SKIPPED_VMS[*]}"
          echo "SKIPPED_VMS=${SKIPPED_VMS[*]}" >> $GITHUB_ENV
          
          if [[ ${#ACTIVE_VM_NAMES[@]} -eq 0 ]]; then
            echo "No active VMs found! Exiting with warning..." | tee -a skipped_vms.log
            exit 1
          fi

          echo "ACTIVE_VM_NAMES=${ACTIVE_VM_NAMES[*]}" >> $GITHUB_ENV

      - name: Upload Extension Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: extension-logs
          path: extension_logs/

      - name: Upload Skipped VMs Log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: skipped-vms-log
          path: skipped_vms.log

      - name: Upload Debug Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-logs
          path: debug_logs/

      # Debug step - remove after testing
      - name: Debug Single VM (Remove after testing)
        if: failure()
        run: |
          echo "=== DEBUG: Testing single VM ==="
          VM_NAME="test1"
          RESOURCE_GROUP="EXAMPLE-RESOURCES"
          
          echo "1. Checking VM status..."
          az vm show --name "$VM_NAME" --resource-group "$RESOURCE_GROUP" --query "powerState" --output tsv
          
          echo "2. Testing simple run command..."
          az vm run-command invoke \
            --name "$VM_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --command-id RunShellScript \
            --scripts "echo 'Hello World' && uname -m" \
            --output json
          
          echo "3. Checking extensions..."
          az vm extension list --vm-name "$VM_NAME" --resource-group "$RESOURCE_GROUP" --output table